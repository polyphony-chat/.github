# Polyphony Specification

**v0.0.0**

This document defines a set of protocols and APIs for a chat service primarily focused on communities. The document is intended to be used as a reference for developers who want to implement a client or server for the Polyphony chat service. Uses of this protocol, hereafter referred to as "the Polyphony protocol", include Instant Messaging, Voice over IP, and Video over IP, where your identity is federated between multiple servers.

It is imperative that implementations of this protocol respect all aspects of this specification.

The structure of this reference document is heavily inspired by the really well written [Matrix specification](https://spec.matrix.org/latest).

## 1. Polyphony APIs

The specification defines a set of APIs that are used to implement the Polyphony protocol. These APIs are:

- Client-Server API
- Server-Server API

### 1.1. Client-Server API

The Client-Server API is a RESTful API that is used by clients to communicate with the server. It is a modification of the Discord v9 API and is completely backwards compatible with it, even if not all endpoints are supported. An example of an unsupported endpoint would be the "Super-reactions" endpoint, which are treated as regular reactions by Polyphony.

### 1.2. Server-Server API

The Server-Server APIs are used to enable federation between multiple Polyphony servers (federated identity).
TODO

## 2. Federated Identity

Federating user identities means that users can fully participate on other instances. This means that users can, for example, DM users from another server or join external Guilds. Each Polyphony user/client must hold on to a private-key.

This key is given to the user by their home server, and is used to sign messages that the user sends to other servers.

**Example:**
Say that Alice is on server A, and Bob is on server B. Alice wants to send a message to Bob.

Alice's client will send a message to her home server (Server A), asking it to generate a federation token for registering on server B. Alice takes this token and sends it to server B. Server B will then ask server A if the token is valid. If all goes well, server B will send a newly generated session token back to Alice's client. Alice's client can then authenticate with server B using this token, and send the message to server B. Server B will then send the message to Bob's client.

```
Alice's Client              Server A            Server B            Bob's Client
|                           |                   |                   |
|-Federation token request->|                   |                   |
|                           |                   |                   |
|<-----Federation token-----|                   |                   |
|                       [Federation handshake start]                |
|                           |                   |                   |
|---------Federation token+Profile------------->|                   |
|                           |                   |                   |
|                           |<--Verification?---|                   |
|                           |                   |                   |
|                           |-----Yes, valid--->|                   |
|                           |                   |                   |
|<----------------Session Token-----------------|                   |
|                           |                   |                   |
|                      [Federation handshake complete]              |
|                           |                   |                   |
|---------Session Token+Signed message--------->|                   |
|                           |                   |                   |
|                           |                   |--Signed message-->|
|                           |                   |                   |
```

Fig. 1: Sequence diagram of a successful federation handshake.

If Alice's session token expires, or if Alice would like to sign in on another device, she can repeat this process of generating a federation token and exchanging it for a session token.

The usage of a federation token prevents a malicious user from generating an external session token on behalf of another user.

## 2.1 Signing messages

As mentioned in the previous section, users must hold on to a private key at all times. This key is used to sign all messages that the user sends to other instances. The key is generated by the user's home server, and is sent to the user's client when the user first registers on the server. The key is stored in the client's local storage. The signing key must not be used for encryption purposes.

Signing messages prevents a malicious server from impersonating a user.

## 2.2 Federation-JWT and Signing Key

A home server may choose to rotate a users signing key at any time. When this happens, the home server will send a new signing key to the user. The user's client will have to save this updated key and use it when communicating with other servers. The home server has to keep track of the old signing key, and use it to verify messages that were signed with the old key.

The JWT and signing key both should be generated using the ed25519 algorithm. Both keys should be signed using the home servers' private key, so that home servers act as a certificate authority for their users' keys.

## 2.3 Reducing network strain when verifying signatures

If Bob receives a message from Alice, he will ask Server B to provide the public key of Alice at the time the message was sent. Server B will then ask Server A for this key. Server A will then send the appropriate key to Server B. Server B will then store this key in its database and forward it to Bob. Bobs' client should then ask Server A for its signing key, cache this key and verify that Server B has stored/provided the correct public key for Alice at the time the message was sent. Should Bob want to re-verify the signature of Alice's message in the future, or should another User of Server B want to verify the signature of Alice's message, Server B will already have the public key cached.

Bob's client could always ask Server A for the public key of Alice, but this would put unnecessary strain on the network. This is why Server B should cache the public keys of users from other instances.

## 2.4 Best practices

### 2.4.1. Signing keys

- Instance/user signing keys should be rotated at least every 30 days. This is to ensure that a compromised key can only be used for a limited amount of time.
- If Bobs client fails to verify the signature of Alice's message with the public key provided by Server B, it should ask Server A for the public key of Alice at the time the message was sent. If the verification fails again, the message should be treated with extreme caution.

## 3. Users

Each client must have a user associated with it. A user is identified by a unique federation ID (FID), which consists of the user's username (which must be unique on the instance) and the instance's root domain. An FID is formatted as follows: `user@domain.tld`, which makes for a globally unique user ID. Federation IDs are case-insensitive.

The following regex can be used to validate user IDs: `\b([A-Z0-9._%+-]+)@([A-Z0-9.-]+\.[A-Z]{2,})\b`.
